# -*- coding: utf-8 -*-
"""Processamento de Imagens

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mXk7JyqdDnKgZkxZinBo6B1rVJHqsfOG
"""

import cv2
import numpy as np
import random
import os

diretorio_arvores = "/content/drive/My Drive/Árvores/Output"
diretorio_cenarios = "/content/drive/My Drive/Árvores/Cenários"
diretorio_imagens_combinadas = "/content/drive/My Drive/Árvores/Imagens_Combinadas"
diretorio_textos = "/content/drive/My Drive/Árvores/Textos"

if not os.path.exists(diretorio_imagens_combinadas):
    os.makedirs(diretorio_imagens_combinadas)
if not os.path.exists(diretorio_textos):
    os.makedirs(diretorio_textos)

#Pegando todos os cenários e árvores
cenarios = [os.path.join(diretorio_cenarios, img) for img in os.listdir(diretorio_cenarios) if img.endswith((".jpg", ".png"))]
trees = [os.path.join(diretorio_arvores, img) for img in os.listdir(diretorio_arvores) if img.endswith((".jpg", ".png"))]

def remove_white_background(image):
    #Escala de cinza e máscara
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    _, mask = cv2.threshold(gray, 240, 255, cv2.THRESH_BINARY_INV)

    #Separa canais da imagem original
    b, g, r = cv2.split(image)

    #Nova imagem com 4 canais (RGBA), onde o canal A (alfa) é a máscara
    alpha = mask
    imagem_sem_fundo = cv2.merge([b, g, r, alpha])

    return imagem_sem_fundo

def paste_tree_on_background(background, tree, position):

    imagem_sem_fundo = remove_white_background(tree)

    #Pegando as coordenadas para colar a árvore
    h_bg, w_bg, _ = background.shape
    h_tree, w_tree, _ = imagem_sem_fundo.shape
    x, y = position

    #Não ultrapassar limite!!
    if x + w_tree > w_bg:
        x = w_bg - w_tree
    if y + h_tree > h_bg:
        y = h_bg - h_tree

    #Pegando os canais de cor e o canal alfa da árvore
    b_tree, g_tree, r_tree, alpha_tree = cv2.split(imagem_sem_fundo)

    #Onde a árvore vai ser colada
    roi = background[y:y+h_tree, x:x+w_tree]

    #Vendo se o ROI tem 3 canais para combinar com a árvore sem o fundo
    if roi.shape[2] == 4:
        roi = roi[:, :, :3]

    #Usando o canal alfa como máscara para misturar a árvore no ROI
    alpha_tree = alpha_tree / 255.0  #Normalizar o canal alfa para ter valores entre 0 e 1

    #Mesclar o ROI com a árvore usando a transparência
    for c in range(0, 3):
        roi[:, :, c] = (alpha_tree * [b_tree, g_tree, r_tree][c] + (1 - alpha_tree) * roi[:, :, c])

    #Colar a árvore mesclada no fundo
    background[y:y+h_tree, x:x+w_tree] = roi

    return background, (x, y, w_tree, h_tree)

def generate_images_and_texts(num_images=180):
    for i in range(num_images):
        bg_image_path = random.choice(cenarios)
        chosen_trees = random.sample(trees, 3)

        background = cv2.imread(bg_image_path)

        texts = []

        for tree_path in chosen_trees:
            tree = cv2.imread(tree_path)

            altura_bg, largura_bg, _ = background.shape
            altura_arvore, largura_arvore, _ = tree.shape

            #Se a árvore for maior que o cenário vou redimensionar
            if altura_arvore > altura_bg or largura_arvore > largura_bg:
                scale_factor = min(largura_bg / largura_arvore, altura_bg / altura_arvore)
                tree = cv2.resize(tree, None, fx=scale_factor, fy=scale_factor)
                altura_arvore, largura_arvore, _ = tree.shape

            #Posição aleatória
            pos_x = random.randint(0, largura_bg - largura_arvore)
            pos_y = random.randint(0, altura_bg - altura_arvore)

            #Colando a árvore no cenário
            background, (x, y, largura_arvore, altura_arvore) = paste_tree_on_background(background, tree, (pos_x, pos_y))

            #Dados do texto
            center_x = (x + largura_arvore / 2) / largura_bg
            center_y = (y + altura_arvore / 2) / altura_bg
            largura = largura_arvore / largura_bg
            altura = altura_arvore / altura_bg

            texts.append(f"0 {center_x} {center_y} {largura} {altura}")

        #Salvando a imagem final
        output_image_path = os.path.join(diretorio_imagens_combinadas, f"composed_image_{i+1}.jpg")
        cv2.imwrite(output_image_path, background)

        #Salvando o texto
        label_path = os.path.join(diretorio_textos, f"composed_image_{i+1}.txt")
        with open(label_path, "w") as label_file:
            label_file.write("\n".join(texts))

        print(f"Imagem {i+1} e anotação gerada com sucesso!")

generate_images_and_texts(num_images=180)



