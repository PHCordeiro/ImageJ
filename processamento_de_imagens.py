# -*- coding: utf-8 -*-
"""Processamento de Imagens

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mXk7JyqdDnKgZkxZinBo6B1rVJHqsfOG
"""

import cv2
import numpy as np
import os
from google.colab.patches import cv2_imshow

def save_rois(image, contours, output_dir, min_area=50):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    roi_count = 0

    for i, contour in enumerate(contours):
        area = cv2.contourArea(contour)
        #Vendo se a área do roi é maior ou igual a mínima (reduz ruídos)
        if area >= min_area:
            #Bounding Box - Envolve a região de interesse
            x, y, w, h = cv2.boundingRect(contour)
            roi = image[y:y+h, x:x+w]

            #Salvando a ROI em um arquivo
            roi_filename = os.path.join(output_dir, f"roi_{roi_count+1}.jpg")
            cv2.imwrite(roi_filename, roi)
            roi_count += 1


input_dir = "/content/drive/My Drive/Árvores/Input"
output_base_dir = "/content/drive/My Drive/Árvores/Output"
min_area = 50

#Passando por todas as imagens no diretório de input
for image_name in os.listdir(input_dir):
    if image_name.endswith((".jpg", ".png", ".jpeg")):
        #Arrumando path
        image_path = os.path.join(input_dir, image_name)
        #Lendo
        image = cv2.imread(image_path)

        if image is None:
            print(f"Erro ao carregar a imagem {image_name}.")
            continue

        gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        #Passa baixa
        passa_baixa = cv2.GaussianBlur(gray_image, (5, 5), 0)
        #Otsu
        _, otsu_segmented = cv2.threshold(passa_baixa, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

        #COlocando o fundo preto e as regiões de interesse em branco (Invertendo)
        inverted_image = cv2.bitwise_not(otsu_segmented)

        #Kernel 3x3 para fechar a imagem
        kernel = np.ones((3, 3), np.uint8)
        imagem_dilatada = cv2.morphologyEx(inverted_image, cv2.MORPH_CLOSE, kernel)

        #PEgando os contornos das regiões de interesse
        contornos, _ = cv2.findContours(imagem_dilatada, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        imagem_colorida = image.copy()
        #Colorindo (cores diferentes) para cada Região de Interesse
        for i, contour in enumerate(contornos):
            color = list(np.random.random(size=3) * 256)
            cv2.drawContours(imagem_colorida, [contour], -1, color, 2)

        #Exibindo :)
        cv2_imshow(imagem_colorida)

        #Criando diretório de saída para CADA imagem analisada
        image_nome = os.path.splitext(image_name)[0]  #TIrei a extensão, peguei só o nome da imagem msm
        image_output_dir = os.path.join(output_base_dir, image_nome)

        #Só salvo as ROis com área mínima
        save_rois(image, contornos, image_output_dir, min_area)

        print(f"Deu bom para {image_name}! Salvo em: {image_output_dir} >.<")

